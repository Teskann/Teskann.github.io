<!doctype html><html lang="en"><head><meta charset="utf-8"><title>URDFast Documentation - code_generator.py</title><meta name="author" content="Docapy"><link rel="stylesheet" href="style.css"></head><body><div class="navbar"><a href="index.html" class="titla"><span class="title"><span class="blue">URDFast</span> Documentation</span></a><span class="links"><a href="https://github.com/Teskann/URDFast">View Github</a><a href="https://github.com/Teskann/Docapy">About Docapy</a></span></div><h1>code_generator.py</h1><div class="sideMenu"><span class="browse">Browse Project Files</span><span class="blue"><a href="code_generator.html" class="menua">code_generator.py</a></span><a href="code_optimization.html" class="menua">code_optimization.py</a><a href="create_robot_from_urdf.html" class="menua">create_robot_from_urdf.py</a><details class="menuDetails"><summary class="menuSummary">generated</summary><details class="menuDetails"><summary class="menuSummary">Examples</summary><a href="generated/Examples/test_robot.html" class="menua">test_robot.py</a></details></details><details class="menuDetails"><summary class="menuSummary">GUI</summary><details class="menuDetails"><summary class="menuSummary">Images</summary><a href="GUI/Images/source_rc.html" class="menua">source_rc.py</a></details><a href="GUI/info_dialog.html" class="menua">info_dialog.py</a><a href="GUI/main_gui.html" class="menua">main_gui.py</a><a href="GUI/main_window.html" class="menua">main_window.py</a><a href="GUI/source_rc.html" class="menua">source_rc.py</a></details><a href="Language.html" class="menua">Language.py</a><a href="polynomial_trajectory.html" class="menua">polynomial_trajectory.py</a><a href="URDF.html" class="menua">URDF.py</a><a href="urdfast.html" class="menua">urdfast.py</a></div><div class="content"><h2>File Description</h2> <b>Created on Fri Jun 19 21</b>:44:37 2020<br> <b>@author</b>: Cl√©ment<h2>Imports</h2><h3>From This Project</h3><ul><li><a href="./code_optimization.html" class="import">code_optimization</a></li><li><a href="./URDF.html" class="import">URDF</a></li><li><a href="./create_robot_from_urdf.html" class="import">create_robot_from_urdf</a></li><li><a href="./Language.html" class="import">Language</a></li><li><a href="./polynomial_trajectory.html" class="import">polynomial_trajectory</a></li></ul></ul><h3>Standard Packages</h3><ul><li><a href="https://docs.python.org/3/library/datetime.html" class="import">datetime</a></li></ul><h3>External Packages</h3><ul><li><a href="https://pypi.org/project/sympy" class="import">sympy</a></li><li><a href="https://pypi.org/project/anytree" class="import">anytree</a></li></ul>If you don't have them, you can install these packages running <a href="https://pypi.org/project/pip/">pip</a> :<br><div class="code">$ <span class="blue">pip</span> install sympy<br></div><div class="code">$ <span class="blue">pip</span> install anytree<br></div><h2>Functions & Classes</h2><details><summary><span class="def">def</span> <span class="blue">generate_code_from_sym_mat</span>(sympy_matrix, fname, language=Language('python'), docstr=None)</summary><h3>Description</h3> Generates code from the Sympy Matrix expression.<br> Python generated code uses numpy dependency to deal with matrices.<br> This only generates the body of the function<br><h3>Parameters</h3> <b>sympy_matrix </b>: sympy.matrices.dense.MutableDenseMatrix<div class="indent"> Sympy matrix to convert to code<br></div> <b>fname </b>: str:<div class="indent"> Function Name<br></div> <b>language </b>: Language<div class="indent"> <b>Language for code generation. Supported values are </b>:<div class="indent"><ul><li> Language(&apos;Python&apos;)</li></ul><br></div> Defaluts to &apos;python&apos;<br></div> <b>docstr </b>: str, optional<div class="indent"> Docstring of the function Default is None<br></div><h3>Returns</h3> <b>code </b>: str<div class="indent"> string containing the generated code<br></div></details><details><summary><span class="def">def</span> <span class="blue">generate_all_matrices</span>(robot, list_ftm, list_btm, language=Language('python'))</summary><h3>Description</h3> Generate all transformation matrices for each joint of the robot<br><h3>Parameters</h3> <b>robot </b>: create_robot_from_urdf.Robot<div class="indent"> Robot you want to generate the matrices from<br></div> <b>list_ftm </b>: list of str<div class="indent"> List of all the forward transition matrices to generate Every element is a string formatted like the nodes <b>names of robot.tree </b>:<div class="indent"> type_number<br> where  type  is &apos;joint&apos; (in this case) and number is the number of the considered Joint in robot.joints.<br> <b>Example </b>: list_ftm=[&apos;joint_3&apos;, &apos;joint_2&apos;]<br></div></div> <b>list_ftm </b>: list of str<div class="indent"> List of all the backward transition matrices to generate Every element is a string formatted like the nodes <b>names of robot.tree </b>:<div class="indent"> type_number<br> where  type  is &apos;joint&apos; (in this case) and number is the number of the considered Joint in robot.joints<br> <b>Example </b>: list_btm=[&apos;joint_3&apos;, &apos;joint_2&apos;]<br></div></div> <b>language </b>: Language.Language, optional<div class="indent"> Language you want the code to be generated to Defalut is Language(&apos;python&apos;)<br></div><h3>Returns</h3> <b>str </b>:<div class="indent"> String containing the code of all the functions<br></div></details><details><summary><span class="def">def</span> <span class="blue">generate_fk</span>(robot, origin, destination, language=Language('python'))</summary><h3>Description</h3> Generate function to compute forward kinematics. This   function    generates    code   using   generated   matrices   from generate_all_matrices.  Consider  using this function after having run the generate_all_matrices function<br><h3>Parameters</h3> <b>robot </b>: create_robot_from_urdf.Robot<div class="indent"> Robot you want to generate the matrices from<br></div> <b>origin </b>: str<div class="indent"> Origin  element  of the FK. Is a string formatted like the nodes <b>names of self.tree </b>:<div class="indent"> type_number<br> where type is &apos;joint&apos; / &apos;link&apos; and number is the number of the considered Joint / Link in self.joints / self.links.<br> <b>Example </b>: origin=&apos;joint_2&apos;</div></div> <b>destination </b>: str<div class="indent"> Destination  element  of  the FK. Is a string formatted like the <b>node names of self.tree </b>:<div class="indent"> type_number<br> where type is &apos;joint&apos; / &apos;link&apos; and number is the number of the considered Joint / Link in self.joints / self.links.<br> <b>Example </b>: destination=&apos;link_0&apos;<br></div></div> <b>language </b>: Language.Language, optional<div class="indent"> Language you want the code to be generated to Defalut is Language(&apos;python&apos;)<br></div><h3>Returns</h3> <b>str </b>:<div class="indent"> String  containing the forward kinematics function in the language you want<br></div></details><details><summary><span class="def">def</span> <span class="blue">generate_all_fk</span>(robot, list_origin, list_dest, language=Language('python'))</summary><h3>Description</h3> Generate all forward kinematics functions<br><h3>Parameters</h3> <b>robot </b>: create_robot_from_urdf.Robot<div class="indent"> Robot you want to generate the matrices from<br></div> <b>list_origin </b>: list of str<div class="indent"> List of all origins elements. Every element is a string formatted like the nodes <b>names of self.tree </b>:<div class="indent"> type_number<br> where type is &apos;joint&apos; / &apos;link&apos; and number is the number of the considered Joint / Link in self.joints / self.links.<br> <b>Example </b>: origin=&apos;joint_2&apos;</div></div> <b>list_dest </b>: list of str<div class="indent"> Every element is a string formatted like the <b>node names of self.tree </b>:<div class="indent"> type_number<br> where type is &apos;joint&apos; / &apos;link&apos; and number is the number of the considered Joint / Link in self.joints / self.links.<br> <b>Example </b>: destination=&apos;link_0&apos;<br></div></div> <b>language </b>: Language.Language, optional<div class="indent"> Language you want the code to be generated to Default is Language(&apos;python&apos;)<br></div><h3>Returns</h3> <b>str </b>:<div class="indent"> String  containing the forward kinematics function in the language you want<br></div></details><details><summary><span class="def">def</span> <span class="blue">generate_jacobian</span>(robot, origin, destination, language=Language('python'))</summary><h3>Description</h3> Generate function to compute 6xn Jacobian where n is the number  of DoF of the robot from origin to destination This   function    generates    code   using   generated   matrices   from generate_all_matrices.  Consider  using this function after having run the generate_all_matrices function<br><h3>Parameters</h3> <b>robot </b>: create_robot_from_urdf.Robot<div class="indent"> Robot you want to generate the matrices from<br></div> <b>origin </b>: str<div class="indent"> Origin  element  of the FK. Is a string formatted like the nodes <b>names of self.tree </b>:<div class="indent"> type_number<br> where type is &apos;joint&apos; / &apos;link&apos; and number is the number of the considered Joint / Link in self.joints / self.links.<br> <b>Example </b>: origin=&apos;joint_2&apos;<br></div></div> <b>destination </b>: str<div class="indent"> Destination  element  of  the FK. Is a string formatted like the <b>node names of self.tree </b>:<div class="indent"> type_number<br> where type is &apos;joint&apos; / &apos;link&apos; and number is the number of the considered Joint / Link in self.joints / self.links.<br> <b>Example </b>: destination=&apos;link_0&apos;<br></div></div> <b>language </b>: Language.Language, optional<div class="indent"> Language you want the code to be generated to Defalut is Language(&apos;python&apos;)<br></div><h3>Returns</h3> <b>str </b>:<div class="indent"> String  containing the forward kinematics function in the language you want<br></div></details><details><summary><span class="def">def</span> <span class="blue">generate_all_jac</span>(robot, list_origin, list_dest, language=Language('python'))</summary><h3>Description</h3> Generate all Jacobian functions<br><h3>Parameters</h3> <b>robot </b>: create_robot_from_urdf.Robot<div class="indent"> Robot you want to generate the matrices from<br></div> <b>list_origin </b>: list of str<div class="indent"> List of all origins elements. Every element is a string formatted like the nodes <b>names of self.tree </b>:<div class="indent"> type_number<br> where type is &apos;joint&apos; / &apos;link&apos; and number is the number of the considered Joint / Link in self.joints / self.links.<br> <b>Example </b>: origin=&apos;joint_2&apos;</div></div> <b>list_dest </b>: list of str<div class="indent"> Every element is a string formatted like the <b>node names of self.tree </b>:<div class="indent"> type_number<br> where type is &apos;joint&apos; / &apos;link&apos; and number is the number of the considered Joint / Link in self.joints / self.links.<br> <b>Example </b>: destination=&apos;link_0&apos;<br></div></div> <b>language </b>: Language.Language, optional<div class="indent"> Language you want the code to be generated to Default is Language(&apos;python&apos;)<br></div><h3>Returns</h3> <b>str </b>:<div class="indent"> String  containing the jacobian functions in the language you want<br></div></details><details><summary><span class="def">def</span> <span class="blue">generate_com</span>(robot, language=Language('python'))</summary><h3>Description</h3> Generate the code for the center of mass of the robot<br><h3>Parameters</h3> <b>robot </b>: create_robot_from_urdf.Robot<div class="indent"> Robot you want to generate the center of mass function from<br></div> <b>language </b>: Language.Language, optional<div class="indent"> Language you want the code to be generated to Default is Language(&apos;python&apos;)<br></div><h3>Returns</h3> <b>str </b>:<div class="indent"> Code of the CoM function in the desired language<br></div></details><details><summary><span class="def">def</span> <span class="blue">generate_com_jacobian</span>(robot, language=Language('python'))</summary><h3>Description</h3> Generate the code for the jacobian of the center of mass of the robot<br><h3>Parameters</h3> <b>robot </b>: create_robot_from_urdf.Robot<div class="indent"> Robot you want to generate the center of mass jacobian function from<br></div> <b>language </b>: Language.Language, optional<div class="indent"> Language you want the code to be generated to Defalut is Language(&apos;python&apos;)<br></div><h3>Returns</h3> <b>str </b>:<div class="indent"> Code of the CoM Jacobian function in the desired language<br></div></details><details><summary><span class="def">def</span> <span class="blue">generate_polynomial_trajectory</span>(conditions, function_name, language)</summary><h3>Description</h3> Generates all the functions of the polynomial trajectory following the conditions you wish. All the derivatives are generated.<br><h3>Parameters</h3> <b>conditions </b>: list of lists containing 3 elements<div class="indent"> [..., [derivative_order, time_value, equals], ...]<br> <b>derivative_order </b>: str<div class="indent"> String containing a positive integer. Order  of  the derivative. If the time is your derivative variable and  the  function  you  want to create describes your position, 0 corresponds to the position, 1 to the speed, 2 to the acceleration 3 to the jerk and so on.</div> <b>time_value </b>: str<div class="indent"> Time value on which you want your condition to be set. This can be a Float string (&quot;1&quot;, &quot;25.04&quot;) or a literal expression representing a variable (&quot;t&quot;, &quot;t0&quot;, &quot;tf&quot;, ...)</div> <b>equals </b>: str<div class="indent"> Value  of  the  function  for  the  given time. This can bea Float string (&quot;1&quot;, &quot;25.04&quot;) or a literal expression representing a variable (&quot;t&quot;, &quot;t0&quot;, &quot;tf&quot;, ...)<br></div></div> <b>function_name </b>: str<div class="indent"> Name of the function of the trajectory<br></div> <b>language </b>: Language.Language<div class="indent"> Language of the generated code<br></div><h3>Returns</h3> <b>code </b>: str<div class="indent"> Code of the functions of all the polynomial derivatives.<br> The generated code will be optimized automatically.<br> The  name  of  the functions are d&lt;k&gt;_&lt;function_name&gt; where &lt;k&gt; is the derivative  order  and  &lt;function_name&gt;  is the function name given as parameter.<br> For example, if your function name is &quot;poly_1&quot;, the generated function for the 2nd derivative (acceleration) will be called &quot;d2_poly_1()&quot;. The 0th derivative (position) will give &quot;d0_poly_1()&quot;.<br></div><h3>Nested Functions</h3><details><summary><span class="def">def</span> <span class="blue">str_to_sym_or_float</span>(string)</summary><h3>Description</h3> Convert the expression in a string to a Sympy variable or a float.<br><h3>Parameters</h3> <b>string </b>: string containing the value.<div class="indent"> This must NOT contain a mathematical expression. Allowed values are for example &quot;2&quot;, &quot;10.5&quot;, &quot;k0&quot;, &quot;t&quot; ...<br></div><h3>Returns</h3> <b>sym </b>: sympy.core.symbol.Symbol or float<div class="indent"> If  the  string  represents  a  number, the function will return a float.  Else,  it  will  return a Sympy symbol associated with the string.<br></div></details></details><details><summary><span class="def">def</span> <span class="blue">generate_all_polynomial_trajectories</span>(trajectories, language)</summary><h3>Description</h3> Generates  the  code for all the polynomial trajectories. For more details on how it works, check generate_polynomial_trajectory() (in this file).<br><h3>Parameters</h3> <b>trajectories </b>: list of dict<div class="indent"> list of all the polynomial trajectories to generate.<br> <b>Every item of this list must be a dict with the following structure </b>:<br> <b>{&quot;name&quot;</b>: str : Name of the trajectory,<br> <b>&quot;conditions&quot; </b>: list of list of 3 str :<br><div class="indent"> [..., [k, t, x], ...]<br> <b>k </b>: str representing an integer<div class="indent"> Order  of  the  derivative.  If  the  time  is your derivative variable  and  the function you  want to create describes your position,  0 corresponds to the position, 1 to the speed, 2 to the acceleration, 3 to the jerk and so on.</div> <b>t </b>: str representing a float or a symbol<div class="indent"> Time value on which you want your condition to be set</div> <b>x </b>: str representing a float or a symbol<div class="indent"> Value  of the  function  for  the  given  time.  This can be a symbolic variable</div></div> }<br></div> <b>language </b>: Language.Language<div class="indent"> Language of the generated code<br></div><h3>Returns</h3> <b>code </b>: str<div class="indent"> Code containing all the functions for each trajectory.<br> The generated code will be optimized automatically.<br> The  name  of  the functions are d&lt;k&gt;_&lt;function_name&gt; where &lt;k&gt; is the derivative  order  and  &lt;function_name&gt;  is the function name given as parameter.<br> For example, if your function name is &quot;poly_1&quot;, the generated function for the 2nd derivative (acceleration) will be called &quot;d2_poly_1()&quot;. The 0th derivative (position) will give &quot;d0_poly_1()&quot;.<br></div></details><details><summary><span class="def">def</span> <span class="blue">generate_everything</span>(robot, list_ftm, list_btm, list_fk, list_jac, com, com_jac, polynomial_trajectories, language, filename)</summary><h3>Description</h3> Generates  all  the  desired  functions in the file &apos;filename.xx&apos; where xx stands for the language file extensiton.<br><h3>Parameters</h3> <b>robot </b>: create_robot_from_urdf.Robot<div class="indent"> Robot object for code generation<br></div> <b>list_ftm </b>: list of str<div class="indent"> List of all the forward transition matrices to generate Every element is a string formatted like the nodes <b>names of robot.tree </b>:<div class="indent"> type_number<br> where  type  is &apos;joint&apos; (in this case) and number is the number of the considered Joint in robot.joints.<br> <b>Example </b>: list_ftm=[&apos;joint_3&apos;, &apos;joint_2&apos;]<br></div></div> <b>list_btm </b>: list of str<div class="indent"> List of all the backward transition matrices to generate Every element is a string formatted like the nodes <b>names of robot.tree </b>:<div class="indent"> type_number<br> where  type  is &apos;joint&apos; (in this case) and number is the number of the considered Joint in robot.joints<br> <b>Example </b>: list_btm=[&apos;joint_3&apos;, &apos;joint_2&apos;]<br></div></div> <b>list_fk </b>: list of list of 2 str<div class="indent"> List of all the forward kinematics functions to generate <b>Every element of the list contains 2 elements </b>:<div class="indent"><ul><li> origin</li><li> destination</li></ul><br></div> origin and destination are strings formatted like the nodes <b>names of robot.tree </b>:<div class="indent"> type_number<br> where type is &apos;joint&apos; / &apos;link&apos; and number is the number of the considered Joint / Link in self.joints / self.links.<br> <b>Example </b>: origin = &apos;joint_3&apos;<br></div></div> <b>list_jac </b>: list of list of 2 str<div class="indent"> List of all the jacobian functions to generate <b>Every element of the list contains 2 elements </b>:<div class="indent"><ul><li> origin</li><li> destination</li></ul><br></div> origin and destination are strings formatted like the nodes <b>names of robot.tree </b>:<div class="indent"> type_number<br> where type is &apos;joint&apos; / &apos;link&apos; and number is the number of the considered Joint / Link in self.joints / self.links.<br> <b>Example </b>: origin = &apos;joint_3&apos;<br></div></div> <b>com </b>: bool<div class="indent"> Set  this parameter to True if you want to generate the Center of Mass function.<br></div> <b>com_jac </b>: bool<div class="indent"> Set  this parameter to True if you want to generate the Center of Mass Jacobian.<br></div> <b>polynomial_trajectories </b>: list of dict<div class="indent"> list of all the polynomial trajectories to generate.<br> <b>Every item of this list must be a dict with the following structure </b>:<br> <b>{&quot;name&quot;</b>: str : Name of the trajectory,<br> <b>&quot;conditions&quot; </b>: list of list of 3 str :<br><div class="indent"> [..., [k, t, x], ...]<br> <b>k </b>: str representing an integer<div class="indent"> Order  of  the  derivative.  If  the  time  is your derivative variable  and  the function you  want to create describes your position,  0 corresponds to the position, 1 to the speed, 2 to the acceleration, 3 to the jerk and so on.</div> <b>t </b>: str representing a float or a symbol<div class="indent"> Time value on which you want your condition to be set</div> <b>x </b>: str representing a float or a symbol<div class="indent"> Value  of the  function  for  the  given  time.  This can be a symbolic variable</div></div> }<br></div> <b>language </b>: Language.Language<div class="indent"> Language of the generated code<br></div> <b>filename </b>: str<div class="indent"> Name  of  the  output  file  containing  the  generated  code (without extension)<br></div><h3>Returns</h3> None.<br></details></details></div></body></html>